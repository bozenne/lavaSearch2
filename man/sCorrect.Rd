% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sCorrect.R
\name{sCorrect}
\alias{sCorrect}
\alias{sCorrect.lm}
\alias{sCorrect.gls}
\alias{sCorrect.lme}
\alias{sCorrect.lvmfit}
\alias{sCorrect.list}
\alias{sCorrect.mmm}
\alias{sCorrect.sCorrect}
\title{Satterthwaite Correction and Small Sample Correction}
\usage{
sCorrect(object, param, data, first.order, ssc, df, derivative, iter.max,
  tol.max, trace)

\method{sCorrect}{lm}(object, param = NULL, data = NULL,
  first.order = TRUE, ssc = lava.options()$ssc,
  df = lava.options()$df, derivative = "analytic", iter.max = 100,
  tol.max = 1e-06, trace = 0)

\method{sCorrect}{gls}(object, param = NULL, data = NULL,
  first.order = TRUE, ssc = lava.options()$ssc,
  df = lava.options()$df, derivative = "analytic", iter.max = 100,
  tol.max = 1e-06, trace = 0)

\method{sCorrect}{lme}(object, param = NULL, data = NULL,
  first.order = TRUE, ssc = lava.options()$ssc,
  df = lava.options()$df, derivative = "analytic", iter.max = 100,
  tol.max = 1e-06, trace = 0)

\method{sCorrect}{lvmfit}(object, param = NULL, data = NULL,
  first.order = TRUE, ssc = lava.options()$ssc,
  df = lava.options()$df, derivative = "analytic", iter.max = 100,
  tol.max = 1e-06, trace = 0)

\method{sCorrect}{list}(object, ...)

\method{sCorrect}{mmm}(object, ...)

\method{sCorrect}{sCorrect}(object, param = NULL, data = NULL,
  first.order = TRUE, ssc = lava.options()$ssc,
  df = lava.options()$df, derivative = "analytic", iter.max = 100,
  tol.max = 1e-06, trace = 0)
}
\arguments{
\item{object, x}{a \code{gls}, \code{lme}, or \code{lvm} object.}

\item{param}{[numeric vector, optional] the values of the parameters at which to perform the correction.}

\item{data}{[data.frame, optional] the dataset relative to which the correction should be performed.}

\item{df}{[logical] should the degree of freedoms of the Wald statistic be computed using the Satterthwaite correction?
Otherwise the degree of freedoms are set to \code{Inf}, i.e. a normal distribution is used instead of a Student's t distribution when computing the p-values.}

\item{trace}{[logical] should the execution of the function be traced.}

\item{...}{[internal] only used by the generic method or by the <- methods.}

\item{cluster}{[integer vector] the grouping variable relative to which the observations are iid.
Only required for \code{gls} models with no correlation argument.}

\item{value}{[logical] value for the arguments \code{adjust.Omega} and \code{adjust.n}.}

\item{adjust.Omega}{[logical] should the standard errors of the coefficients be corrected for small sample bias?}

\item{adjust.n}{[logical] should the correction for the degree of freedom be performed?}

\item{tol}{[numeric >0] the minimum absolute difference between two estimation of the small sample bias.
Below this value, the algorithm used to estimate the bias stop.}

\item{n.iter}{[integer >0] the maximum number of iterations used to estimate the small sample bias of the residual variance-covariance matrix.}

\item{numeric.derivative}{[logical] should a numerical derivative be used to compute the first derivative of the information matrix?
Otherwise an analytic formula is used.}
}
\description{
Correct the bias of the ML estimate of the variance and compute the first derivative of the information matrix.
Also@name sCorrect
}
\details{
The argument \code{value} is equivalent to the argument \code{bias.correct} of the function \code{summary2}.
}
\examples{
#### simulate data ####
set.seed(10)
dW <- sampleRepeated(10, format = "wide")
set.seed(10)
dL <- sampleRepeated(10, format = "long")
dL$time2 <- paste0("visit",dL$time)

#### linear model ####
e.lm <- lm(Y1~X1, data = dW)
e2.lm <- sCorrect(e.lm)

#### gls model ####
e.gls1 <- gls(Y1~X1, data = dW)
.getGroups2(e.gls1, data = dW)

e.gls2 <- gls(Y~X1, correlation = corCompSymm(form=~1|id), data = dL)
.getGroups2(e.gls2, data = dL)

e.gls3 <- gls(Y~X1, correlation = corCompSymm(form=~time|id), data = dL)
.getGroups2(e.gls3, data = dL)

e.gls4 <- gls(Y~X1, weight = varIdent(form=~1|time2), data = dL)
.getGroups2(e.gls4, data = dL)

e.gls5 <- gls(Y~X1, weight = varIdent(form=~1|time2),
              correlation = corSymm(form=~time|id), data = dL)
.getGroups2(e.gls5, data = dL)

#### lme model ####
e.lme <- lme(Y~X1, random=~1|id, data = dL)
.getGroups2(e.lme, data = dL)

## latent variable model
e.lvm <- estimate(lvm(formula.lvm),data=d)
sCorrect(e.lvm) <- TRUE ## i.e. bias.correct = TRUE
summary2(e.lvm)

}
\concept{derivative of the score equation}
\concept{small sample inference}
