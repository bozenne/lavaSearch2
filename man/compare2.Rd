% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sCorrect-compare2.R
\name{compare2}
\alias{compare2}
\alias{compare2.lm}
\alias{compare2.gls}
\alias{compare2.lme}
\alias{compare2.lvmfit}
\alias{compare2.sCorrect}
\title{Test Linear Hypotheses with small sample correction}
\usage{
compare2(object, ...)

\method{compare2}{lm}(object, ssc = lava.options()$ssc,
  df = lava.options()$df, ...)

\method{compare2}{gls}(object, ssc = lava.options()$ssc,
  df = lava.options()$df, ...)

\method{compare2}{lme}(object, ssc = lava.options()$ssc,
  df = lava.options()$df, ...)

\method{compare2}{lvmfit}(object, ssc = lava.options()$ssc,
  df = lava.options()$df, ...)

\method{compare2}{sCorrect}(object, linfct = NULL, rhs = NULL,
  robust = FALSE, cluster = NULL, as.lava = TRUE, F.test = TRUE,
  conf.level = 0.95, ...)
}
\arguments{
\item{object}{a \code{lm}, \code{gls}, \code{lme}, or \code{lvmfit} object.}

\item{...}{[logical] arguments passed to lower level methods.}

\item{ssc}{[logical] should the standard errors of the coefficients be corrected for small sample bias? Argument passed to \code{sCorrect}.}

\item{df}{[logical] should the degree of freedoms of the Wald statistic be computed using the Satterthwaite correction?
Otherwise the degree of freedoms are set to \code{Inf}, i.e. a normal distribution is used instead of a Student's t distribution when computing the p-values.}

\item{linfct}{[matrix or vector of character] the linear hypotheses to be tested. Same as the argument \code{par} of \code{\link{createContrast}}.}

\item{rhs}{[vector] the right hand side of the linear hypotheses to be tested.}

\item{robust}{[logical] should the robust standard errors be used instead of the model based standard errors?}

\item{cluster}{[integer vector] the grouping variable relative to which the observations are iid.}

\item{as.lava}{[logical] should the output be similar to the one return by \code{lava::compare}?}

\item{F.test}{[logical] should a joint test be performed?}

\item{conf.level}{[numeric 0-1] the confidence level of the confidence interval.}

\item{transform}{[function] function to backtransform the estimates and the associated confidence intervals
(e.g. \code{exp} if the outcomes have been log-transformed).}
}
\value{
If \code{as.lava=TRUE} an object of class \code{htest}.
Otherwise a \code{data.frame} object.
}
\description{
Test Linear Hypotheses using a multivariate Wald statistic from \code{lm}, \code{gls}, \code{lme}, or \code{lvmfit} objects.
Similar to \code{lava::compare} but with small sample correction (if any).
}
\details{
The \code{par} argument or the arguments \code{contrast} and \code{null} (or equivalenty \code{rhs})
specify the set of linear hypotheses to be tested. They can be written:
\deqn{
  contrast * \theta = null
}
where \eqn{\theta} is the vector of the model coefficients. \cr
The \code{par} argument must contain expression(s) involving the model coefficients.
For example \code{"beta = 0"} or \code{c("-5*beta + alpha = 3","-alpha")} are valid expressions if alpha and beta belong to the set of model coefficients.
A contrast matrix and the right hand side will be generated inside the function. \cr

When directly specified, the contrast matrix must contain as many columns as there are coefficients in the model (mean and variance coefficients).
Each hypothesis correspond to a row in the contrast matrix. \cr

The null vector should contain as many elements as there are row in the contrast matrix. \cr

Argument rhs and null are equivalent.
This redondance enable compatibility between \code{lava::compare}, \code{compare2}, \code{multcomp::glht}, and \code{glht2}.
}
\examples{
#### simulate data ####
set.seed(10)
mSim <- lvm(Y~0.1*X1+0.2*X2)
categorical(mSim, labels = c("a","b","c")) <- ~X1
transform(mSim, Id~Y) <- function(x){1:NROW(x)}
df.data <- lava::sim(mSim, 1e2)

#### with lm ####
## direct use of compare2
e.lm <- lm(Y~X1+X2, data = df.data)
anova(e.lm)
compare2(e.lm, par = c("X1b=0","X1c=0"))

## or first compute the derivative of the information matrix
sCorrect(e.lm) <- TRUE

## and define the contrast matrix
C <- createContrast(e.lm, linfct = c("X1b=0","X1c=0"), add.variance = TRUE)

## run compare2
compare2(e.lm, linfct = C$contrast, rhs = C$null)
compare2(e.lm, linfct = C$contrast, rhs = C$null, robust = TRUE)

#### with gls ####
library(nlme)
e.gls <- gls(Y~X1+X2, data = df.data, method = "ML")

## first compute the derivative of the information matrix
sCorrect(e.gls, cluster = 1:NROW(df.data)) <- TRUE

compare2(e.gls, par = c("5*X1b+2*X2 = 0","(Intercept) = 0"))

#### with lvm ####
m <- lvm(Y~X1+X2)
e.lvm <- estimate(m, df.data)

compare2(e.lvm, par = c("-Y","Y~X1b+Y~X1c"))
compare2(e.lvm, par = c("-Y","Y~X1b+Y~X1c"), robust = TRUE)
}
\seealso{
\code{\link{createContrast}} to create contrast matrices. \cr
\code{\link{sCorrect}} to pre-compute quantities for the small sample correction.
}
\concept{small sample inference}
