% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compare2.R
\name{compare2}
\alias{compare2}
\alias{compare2.lm}
\alias{compare2.gls}
\alias{compare2.lme}
\alias{compare2.lvmfit}
\alias{compare2.lm2}
\alias{compare2.gls2}
\alias{compare2.lme2}
\alias{compare2.lvmfit2}
\alias{.compare2}
\title{Test Linear Hypotheses with small sample correction}
\usage{
compare2(object, ...)

\method{compare2}{lm}(object, adjust.residuals = TRUE, ...)

\method{compare2}{gls}(object, adjust.residuals = TRUE, ...)

\method{compare2}{lme}(object, adjust.residuals = TRUE, ...)

\method{compare2}{lvmfit}(object, adjust.residuals = TRUE, ...)

\method{compare2}{lm2}(object, ...)

\method{compare2}{gls2}(object, ...)

\method{compare2}{lme2}(object, ...)

\method{compare2}{lvmfit2}(object, ...)

.compare2(object, par = NULL, contrast = NULL, null = NULL,
  as.lava = TRUE, level = 0.95, ...)
}
\arguments{
\item{object}{an object that inherits from lm/gls/lme/lvmfit.}

\item{...}{[internal] Only used by the generic method.
One exception: for gls models \code{...} is passed to dVco2,
this can be useful when the argument cluster is required.}

\item{adjust.residuals}{[logical] small sample correction: should the leverage-adjusted residuals be used to compute the score? Otherwise the raw residuals will be used.}

\item{par}{[vector of characters] expression defining the linear hypotheses to be tested.
See the examples section.}

\item{contrast}{[matrix] the contrast matrix defining the left hand side of the linear hypotheses to be tested.}

\item{null}{[vector] the right hand side of the linear hypotheses to be tested.}

\item{as.lava}{[logical] should the output be similar to the one return by \code{lava::compare}.}

\item{level}{[numeric 0-1] the confidence level of the confidence interval.}
}
\description{
Test Linear Hypotheses using a Wald or an F statistic.
Similar to \code{lava::compare} but with small sample correction.
}
\details{
A set of linear hypothesis can be written:
\deqn{
  contrast \theta = null
}
The contrast matrix must contain as many columns as there are parameters in the model (mean and variance parameters).
Each hypothesis correspond to a row in the contrast matrix.
So the null vector should contain as many elements as there are row in the contrast matrix.
The method \code{createContrast} can help to initialize the contrast matrix.
\cr \cr

Instead of a contrast matrix, on can also use expressions encoded in a vector of characters via the argument \code{par}.
For example \code{"beta = 0"} or \code{c("-5*beta + alpha = 3","-alpha")} are valid expressions if alpha and beta belong to the set of model parameters.
}
\examples{
#### simulate data ####
set.seed(10)
mSim <- lvm(Y~0.1*X1+0.2*X2)
categorical(mSim, labels = c("a","b","c")) <- ~X1
transform(mSim, Id~Y) <- function(x){1:NROW(x)}
df.data <- lava::sim(mSim, 1e2)

#### with lm ####
## direct use of compare2
e.lm <- lm(Y~X1+X2, data = df.data)
anova(e.lm)
compare2(e.lm, par = c("X1b=0","X1c=0"))

## or first compute the derivative of the information matrix
dVcov2(e.lm) <- TRUE

## and define the contrast matrix
C <- createContrast(e.lm, par = c("X1b=0","X1c=0"))

## run compare2
compare2(e.lm, contrast = C$contrast, null = C$null)

#### with gls ####
library(nlme)
e.gls <- gls(Y~X1+X2, data = df.data, method = "ML")

## first compute the derivative of the information matrix
dVcov2(e.gls, cluster = 1:NROW(df.data)) <- TRUE

compare2(e.gls, par = c("5*X1b+2*X2 = 0","(Intercept) = 0"))

#### with lvm ####
m <- lvm(Y~X1+X2)
e.lvm <- estimate(m, df.data)

compare2(e.lvm, par = c("-Y","Y~X1b+Y~X1c"))
}
\seealso{
\code{\link{createContrast}} to create contrast matrices. \cr
\code{\link{dVcov2}} to pre-compute quantities for the small sample correction.
}
