### iid2.R --- #----------------------------------------------------------------------## author: Brice Ozenne## created: okt 12 2017 (13:16) ## Version: ## last-updated: feb  7 2020 (13:20) ##           By: Brice Ozenne##     Update #: 578#----------------------------------------------------------------------## ### Commentary: ## ### Change Log:#----------------------------------------------------------------------## ### Code:## * Documentation - iid2#' @title  Extract i.i.d. Decomposition After Small Sample Correction.#' @description  Extract corrected i.i.d. decomposition from \code{lm}, \code{gls}, \code{lme}, or \code{lvmfit} objects.#' It is similar to \code{lava::iid} but with small sample correction (if any).#' #' @name iid2#'#' @param object a \code{lm}, \code{gls}, \code{lme}, or \code{lvmfit} object.#' @param cluster [integer vector] the grouping variable relative to which the observations are iid.#' @param robust [logical] if \code{FALSE}, the i.i.d. decomposition is rescaled such its the squared sum equals the model-based standard error (instead of the robust standard error).#' @param as.lava [logical] Should the order and the name of the coefficient be the same as those obtained using coef with type = -1.#' Only relevant for \code{lvmfit} objects.#'#' @details If argument \code{p} or \code{data} is not null, then the small sample size correction is recomputed to correct the influence function.#'#' @seealso \code{\link{sCorrect}} to obtain \code{lm2}, \code{gls2}, \code{lme2}, or \code{lvmfit2} objects.#'#' @return A matrix containing the 1st order influence function relative to each sample (in rows)#' and each model coefficient (in columns).#' #' @examples#' n <- 5e1#' p <- 3#' X.name <- paste0("X",1:p)#' link.lvm <- paste0("Y~",X.name)#' formula.lvm <- as.formula(paste0("Y~",paste0(X.name,collapse="+")))#'#' m <- lvm(formula.lvm)#' distribution(m,~Id) <- sequence.lvm(0)#' set.seed(10)#' d <- sim(m,n)#'#' ## linear model#' e.lm <- lm(formula.lvm,data=d)#' iid.tempo <- iid2(e.lm, bias.correct = FALSE)#' range(iid.tempo[,1:4]-iid(e.lm))#' #' ## latent variable model#' e.lvm <- estimate(lvm(formula.lvm),data=d)#' iid.tempo <- iid2(e.lvm, bias.correct = FALSE)#' range(iid.tempo-iid(e.lvm))#' ## difference due to the use of the observed info matrix vs. the expected one.#'#' ## rescale i.i.d using model-based standard error#' iid.tempo <- iid2(e.lvm, robust = FALSE, bias.correct = FALSE)#' diag(crossprod(iid.tempo))-diag(vcov(e.lvm))#'#' @concept small sample inference#' @concept iid decomposition#' @export`iid2` <-  function(object, ...) UseMethod("iid2")## * iid2.lm#' @rdname iid2#' @exportiid2.lm <- function(object, ssc = lava.options()$ssc, df = lava.options()$df, ...){    object.SSC <- sCorrect(object, ssc = ssc, df = df)    return(iid2(object.SSC, ...))}## * iid2.gls#' @rdname iid2#' @exportiid2.gls <- iid2.lm## * iid2.lme#' @rdname iid2#' @exportiid2.lme <- iid2.lm## * iid2.lvmfit#' @rdname iid2#' @exportiid2.lvmfit <- iid2.lm## * iid2.sCorrect#' @rdname iid2#' @exportiid2.sCorrect <- function(object, robust = TRUE, cluster = NULL, as.lava = TRUE, ...){    ## ** compute iid    object.score <- score2(object, indiv = TRUE, cluster = cluster, as.lava = FALSE)    object.vcov <- vcov2(object, as.lava = FALSE)    object.iid <- object.score %*% object.vcov    if(robust == FALSE){        vec.sigma <- sqrt(diag(object.vcov))        vec.sigma.robust <- sqrt(colSums(object.iid^2))        object.iid <- sweep(object.iid, MARGIN = 2, FUN = "*", STATS = vec.sigma/vec.sigma.robust)    }    ## restaure names    colnames(object.iid) <- colnames(object.score)    if(!is.null(cluster)){        attr(object.iid,"cluster") <- attr(object.score,"cluster")            }    ## ** export    if(as.lava == FALSE){         object.iid <- object.iid[,names(object$sCorrect$skeleton$originalLink2param),drop=FALSE]        dimames(object.iid) <- list(NULL,as.character(object$sCorrect$skeleton$originalLink2param))    }    return(object.iid)}## * Documentation - iid2plot#' @title  Display the i.i.d. Decomposition#' @description  Extract the i.i.d. decomposition and display it along with the corresponding coefficient.#'#' @param object a \code{lm}, \code{gls}, \code{lme}, or \code{lvmfit} object.#' @param param [character] name of one of the model parameters.#'#' @exportiid2plot <- function(object, param){    all.param <- coef2(object)    if(length(param) != 1){        stop("Incorrect argument \'param\'. \n",             "Should have length 1. \n")    }    if(param %in% names(all.param) == FALSE){        stop("Incorrect argument \'param\'. \n",             "Should be one of the model parameters. \n")    }    object.iid <- iid2(object)[,param]    h <- hist(object.iid, main = paste0(param,"=",all.param[param]), xlab = "iid")    return(invisible(h))}##----------------------------------------------------------------------### iid2.R ends here