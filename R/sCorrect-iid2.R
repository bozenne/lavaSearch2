### iid2.R --- #----------------------------------------------------------------------## author: Brice Ozenne## created: okt 12 2017 (13:16) ## Version: ## last-updated: jan  8 2020 (16:38) ##           By: Brice Ozenne##     Update #: 530#----------------------------------------------------------------------## ### Commentary: ## ### Change Log:#----------------------------------------------------------------------## ### Code:## * Documentation - iid2#' @title  Extract i.i.d. Decomposition After Small Sample Correction.#' @description  Extract corrected i.i.d. decomposition from \code{lm}, \code{gls}, \code{lme}, or \code{lvmfit} objects.#' It is similar to \code{lava::iid} but with small sample correction (if any).#' #' @name iid2#'#' @param object a \code{lm}, \code{gls}, \code{lme}, or \code{lvmfit} object.#' @param param [named numeric vector] the fitted parameters.#' @param data [data.frame] the data set.#' @param cluster [integer vector] the grouping variable relative to which the observations are iid.#' @param bias.correct [logical] should the standard errors of the coefficients be corrected for small sample bias? Only relevant if the \code{sCorrect} function has not yet be applied to the object.#' @param robust [logical] if \code{FALSE}, the i.i.d. decomposition is rescaled such its the squared sum equals the model-based standard error (instead of the robust standard error).#' @param ... arguments to be passed to \code{sCorrect}.#'#' @details If argument \code{p} or \code{data} is not null, then the small sample size correction is recomputed to correct the influence function.#'#' @seealso \code{\link{sCorrect}} to obtain \code{lm2}, \code{gls2}, \code{lme2}, or \code{lvmfit2} objects.#'#' @return A matrix containing the 1st order influence function relative to each sample (in rows)#' and each model coefficient (in columns).#' #' @examples#' n <- 5e1#' p <- 3#' X.name <- paste0("X",1:p)#' link.lvm <- paste0("Y~",X.name)#' formula.lvm <- as.formula(paste0("Y~",paste0(X.name,collapse="+")))#'#' m <- lvm(formula.lvm)#' distribution(m,~Id) <- sequence.lvm(0)#' set.seed(10)#' d <- sim(m,n)#'#' ## linear model#' e.lm <- lm(formula.lvm,data=d)#' iid.tempo <- iid2(e.lm, bias.correct = FALSE)#' range(iid.tempo[,1:4]-iid(e.lm))#' #' ## latent variable model#' e.lvm <- estimate(lvm(formula.lvm),data=d)#' iid.tempo <- iid2(e.lvm, bias.correct = FALSE)#' range(iid.tempo-iid(e.lvm))#' ## difference due to the use of the observed info matrix vs. the expected one.#'#' ## rescale i.i.d using model-based standard error#' iid.tempo <- iid2(e.lvm, robust = FALSE, bias.correct = FALSE)#' diag(crossprod(iid.tempo))-diag(vcov(e.lvm))#'#' @concept small sample inference#' @concept iid decomposition#' @export`iid2` <-  function(object, robust, param, data, ssc, cluster) UseMethod("iid2")## * iid2.lm#' @rdname iid2#' @exportiid2.lm <- function(object, robust = TRUE, param = NULL, data = NULL,                    ssc = lava.options()$ssc, cluster = NULL){    if(is.null(object$sCorrect) || !is.null(param) || !is.null(data) || !identical(object$sCorrect$ssc$type,ssc)){        object <- sCorrect(object, param = param, data = data, ssc = ssc, df = NULL)    }    if(is.null(cluster)){        n.cluster <- object$sCorrect$cluster$n.cluster        cluster <- 1:n.cluster    }else{        if(!is.numeric(cluster)){            if(is.null(data)){                data <- object$sCorrect$data            }            if(NROW(data)!=object$sCorrect$cluster$n.cluster){                stop("Argument \'cluster\' can be a character only when the data is in the wide format \n")            }            if(length(cluster)!=1){                stop("When not numeric, argument \'cluster\' must be a character indicating the variable to use in the dataset to identify the clusters \n")            }            if(cluster %in% names(data) == FALSE){                stop("Invalid \'cluster\' argument \n",                     "Could not find variable \"",cluster,"\" in argument \'data\' \n")            }else{                cluster <- as.numeric(as.factor(data[[cluster]]))            }                    }else{            if(length(cluster)!=object$sCorrect$cluster$n.cluster){                stop("The length of argument \'cluster\' must match the number of group of observations \n",                     "Number of group of observations: ",object$sCorrect$cluster$n.cluster,"\n")            }            cluster <- as.numeric(as.factor(cluster))        }        n.cluster <- length(unique(cluster))    }    return(.iid2(score = object$sCorrect$score,                 vcov.param = object$sCorrect$vcov.param,                              cluster = cluster,                 n.cluster = n.cluster,                 robust = robust))}## * iid2.gls#' @rdname iid2#' @exportiid2.gls <- iid2.lm## * iid2.lme#' @rdname iid2#' @exportiid2.lme <- iid2.lm## * iid2.lvmfit#' @rdname iid2#' @exportiid2.lvmfit <- iid2.lm## * iid2.sCorrect#' @rdname iidiid2.sCorrect <- function(object, robust = TRUE, param = NULL, data = NULL,                         ssc = object$sCorrect$ssc$type, cluster = NULL){    class(object) <- setdiff(class(object2),"sCorrect")    return(iid2(object, robust = robust, param  = param, data = data, ssc = ssc, clust = cluster))}## * iid.sCorrect#' @rdname iidiid.sCorrect <- iid2.sCorrect## * .iid2.iid2 <- function(score, vcov.param, cluster, n.cluster, robust){    index.cluster <- tapply(1:length(cluster),cluster,list)    scoreCluster <- do.call("rbind",lapply(1:n.cluster, function(iC){ ## iC <- 5        colSums(score[index.cluster[[iC]],,drop=FALSE])    }))    out <- scoreCluster %*% vcov.param        if(robust == FALSE){        vec.sigma <- sqrt(diag(vcov.param))        vec.sigma.robust <- sqrt(apply(out^2,2,sum))        out <- sweep(out, MARGIN = 2, FUN = "*", STATS = vec.sigma/vec.sigma.robust)    }    colnames(out) <- colnames(score)        return(out)    }##----------------------------------------------------------------------### iid2.R ends here